;; to do


;; -rewrite process model to have less redundancy
;; -generate data from the compressed version

;; -compare the data generated from the uncompressed and compressed versions of the program to new data generated by the original concept

(import (_srfi :1)
        (church readable-scheme)
        (church external py-pickle)
        (srfi :13)
        (abstract))

(define draw-trees
  (py-pickle-script "./treedraw.py"))

;;prototype

(define a 'a)
(define b 'b)
(define c 'c)
(define d 'd)
(define e 'e)


(define growth-noise .05)
(define label-noise .05)
(define sample-size 5)
(define labels '(a b c d e))
(define node-def '((define (node x . subtrees)
  (if (flip (- 1 growth-noise))
      (delete '() (pair (noisy-label x) subtrees))
      '()))

(define (noisy-label x)
  (if (flip (- 1 label-noise))
      x
      (uniform-draw labels)))))


(define (node x . subtrees)
  (if (flip (- 1 growth-noise))
      (delete '() (pair (noisy-label x) subtrees))
      '()))

(define (noisy-label x)
  (if (flip (- 1 label-noise))
      x
      (uniform-draw labels)))
  
(node 'a (node 'b) (node 'c (node 'd)))
(define (prototype) (node 'a (node 'b (node 'c (node 'd) (node 'd)))))

(define (parameterized-parts)
  (define (part x)
    (node 'a x (node 'a x (node 'a x (node 'a x x) x) x) x))
  (part (if (flip .5)
            (node 'b)
            (node 'c))))

   
(define (multiple-recursion)
  (define (part)
    (node 'a
          (if (flip .3)
              (part)
              (node 'a))
          (if (flip .04)
              (part)
              (node 'b))))
  (node 'c (node 'b (node 'd (part))) (part)))

(define (gen-data model)
  (delete '() (repeat sample-size model)))

;; (define (draw-data data)
;;   (draw-trees (pair data data)))
;;(draw-trees (pair "./mrecur-data.png" mrecur-data))



(define (nodify-noquote tree)
  (if (null? tree)
      '()
      (append (list 'node (first tree))
              (map nodify-noquote (rest tree)))))

;;(pretty-print (nodify-noquote '(a (b (c)) (d))))


(define (nodify tree)
  (if (null? tree)
      '()
      (append (list 'node (list 'quote (first tree)))
              (map nodify (rest tree)))))


(define (program-exemplar data)
  (let* ([all-examples (map nodify data)])
    (lambda () (eval (uniform-draw all-examples) (interaction-environment)))))

(define (exemplar data)
  (lambda () (uniform-draw data)))


(define (program-compression data)
  (let* ([all-examples (map nodify-noquote data)]
         [prog (program->sexpr (beam-compression (list 'uniform-draw (pair 'list all-examples)) 2))])
    (pretty-print (list "hello" prog))
    (lambda () (eval prog (interaction-environment)))))


(define (process-model model name)
  (let* ([data (gen-data model)]
         [orig-file-name (string-join (list name ".png") "")]
         [exemp (exemplar data)]
         [exemp-data (gen-data exemp)]
         [exemp-file-name (string-join (list name "-exemplar.png") "")]
         [prog-exemplar (program-exemplar data)]
         [prog-exemplar-data (gen-data prog-exemplar)]
         [prog-exemplar-file-name (string-join (list name "-prog-exemplar.png") "")]
         [compress-prog (program-compression data)]
         [compress-prog-data (gen-data compress-prog)]
         [compress-prog-file-name (string-join (list name "-compress.png") "")]
         [new-data (gen-data model)]
         [new-file-name (string-join (list name "-new.png") "")])
    (draw-trees (pair orig-file-name data))
    (draw-trees (pair exemp-file-name exemp-data))
    (draw-trees (pair prog-exemplar-file-name prog-exemplar-data))
    (draw-trees (pair compress-prog-file-name compress-prog-data))
    (draw-trees (pair new-file-name new-data))))

;;(process-model prototype "proto")
         
;;(process-model parameterized-parts "param")

(process-model multiple-recursion "mrecur")

;;(program-compression (gen-data prototype))

;; -fix problem when recursion abstraction is learned off of an abstraction and there is variable capture, this can cause recursion to take a variable value
;; -do program->sexpr inside beam-compression
;; -eval the compressed program
;; -compress the literal translation of the data
