(define (lazy-pair a b) (lambda (tag) (if (eq? tag 'first) a (if (eq? tag 'rest) b 'lazy-pair))))
(define (lazy-pair? a) (if (procedure? a) (eq? 'lazy-pair (a 'type?)) false))

(define lazy-list (lambda args (if (pair? args) (lazy-pair (first args) (apply lazy-list (rest args))) args)))

;;returns false if finds missmatch, otherwise returns amount of sexprs matched.
(define (seq-sexpr-equal? t1 t2 depth)
  (if (= depth 0)
      0
      (if (and (lazy-pair? t1) (lazy-pair? t2))
          (let ((left (seq-sexpr-equal? (t1 'first) (t2 'first) (- depth 1))))
                (if (eq? false left)
                    false
                    (seq-sexpr-equal? (t1 'rest) (t2 'rest) left)))
          (if (eq? t1 t2)
              (- depth 1)
              false))))
(define (lazy-equal? a b depth) (not (eq? false (seq-sexpr-equal? a b depth))))


(define (lazy-list->list a depth)
   (if (= 0 depth)
      (pair 'unf 0)
      (if (lazy-pair? a)
          (let* ((left (lazy-list->list (a 'first) (- depth 1)))
                 (right (lazy-list->list (a 'rest) (rest left))))
            (pair (pair (first left) (first right)) (rest right)))
          (pair a (- depth 1)))))

(define (lazy-map proc lst)
  (apply lazy-list (map proc lst)))

(define obs (lazy-list 'if (lazy-list 'if 't 'f 't) 'f 't))

(define (id x) x)
(define obs2 (lazy-pair 'if (lazy-map id (list (lazy-pair 'if (lazy-map id (list 't 'f 't))) 'f 't)))) 
(pretty-print
(psmc-query (depth) (map list (list 17))
            10
            0

            (define (terminal t) (lambda () t))

            (define EXPR
              (lambda ()
                (sample (multinomial (list IF BOOL) (list 1/4 3/4)))))
            (define IF
              (lambda ()
                (lazy-list 'if (EXPR) (EXPR) (EXPR))))
            (define BOOL
              (lambda ()
                (sample  (uniform-draw (list (terminal 't) (terminal 'f))))))

            (define program (EXPR))

            ;;query expression
            (first (lazy-list->list program depth))
            ;;conditional expression
            (lazy-equal? program obs depth)))

            ;; (define (color)
            ;;   (if (flip) 'a 'b))
            
            ;; (define tree
            ;;   (lazify
            ;;   (lambda ()
            ;;     (if (flip)
            ;;         (color) 
            ;;         (lazy-list (color) (tree) (tree))))))


;(tree-equal? (lazify (node 'a (color) 'b)) (node 'a 'b 'b) 2);(tree) obs 1)

(define obs3 (lazy-list 'a (lazy-list 'a 'b 'b) (lazy-list 'a 'b 'b)))

(pretty-print (lazy-list->list obs 17))
(pretty-print (lazy-list->list obs2 17))

(pretty-print (lazy-list->list obs2 0))
(pretty-print (lazy-list->list obs2 1))
(pretty-print (lazy-list->list obs2 2))
(pretty-print (lazy-list->list obs2 3))
(pretty-print (lazy-list->list obs2 4))
(pretty-print (lazy-list->list obs3 18))
(lazy-equal? obs obs2 20)


(iota 20)
(pretty-print (lazy-list->list (lazy-pair 't 'f) 1))
(pretty-print (lazy-equal? obs (lazy-pair 't 'f) 1))
;;(lazy-list->list '(1 2 3) 5)



